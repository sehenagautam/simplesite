<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Admin Image Label Tool</title>

    <style>
        body {
            font-family: Arial;
            padding: 40px;
            background: #f5f5f5;
        }
        h1 {
            text-align: center;
            font-size: 30px;
            margin-bottom: 30px;
        }
        .container {
            max-width: 950px;
            margin: auto;
            background: white;
            padding: 25px;
            border-radius: 10px;
            box-shadow: 0 3px 8px rgba(0,0,0,0.1);
        }
        .image-block {
            border: 1px solid #ddd;
            padding: 15px;
            margin-top: 20px;
            border-radius: 10px;
            background: #fdfdfd;
        }
        img.preview {
            width: 220px;
            border-radius: 8px;
            margin-bottom: 10px;
            display: block;
        }
        input, textarea {
            width: 100%;
            padding: 10px;
            margin: 8px 0 18px;
            border: 1px solid #ccc;
            border-radius: 6px;
            font-size: 15px;
        }
        textarea {
            min-height: 80px;
            resize: vertical;
        }
        .download-btn {
            padding: 10px 16px;
            background: #28a745;
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            margin-top: 10px;
            font-size: 15px;
        }
        .download-btn:hover {
            background: #1f7e35;
        }

        .download-all-btn {
            padding: 10px 16px;
            background: #007bff;
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            margin-top: 25px;
            font-size: 15px;
        }
        .download-all-btn:hover {
            background: #005fcc;
        }
        .logo-upload {
            margin-bottom: 25px;
            padding: 15px;
            background: #eef3ff;
            border-radius: 10px;
        }
    </style>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
</head>

<body>

<h1><b>Admin Image Label Tool</b></h1>

<div class="container">

    <div class="logo-upload">
        <label><b>Upload Logo (applies to ALL images):</b></label>
        <input type="file" id="logoInput" accept="image/*">
    </div>

    <label><b>Upload Multiple Images:</b></label>
    <input type="file" id="multiInput" accept="image/*" multiple>

    <div id="formHolder"></div>

    <button id="downloadAllBtn" class="download-all-btn">
        Download All Labeled Images (ZIP)
    </button>
</div>

<script>
/* ------------------------------------
   BASE URL for full image paths
------------------------------------- */
const BASE_URL = "https://simplesite1-taupe.vercel.app/";

/* ====================================
   GLOBAL VARIABLES
===================================== */
let logoImageURL = null;

/* ====================================
   LOGO UPLOAD HANDLER
===================================== */
document.getElementById("logoInput").onchange = function(e){
    const file = e.target.files[0];
    if (file) {
        logoImageURL = URL.createObjectURL(file);
    }
};

/* ====================================
   IMAGE UPLOAD HANDLER
===================================== */
document.getElementById("multiInput").onchange = function(e){
    const files = e.target.files;
    let html = "";

    for (let i = 0; i < files.length; i++){
        const file = files[i];
        const url = URL.createObjectURL(file);

        html += `
        <div class="image-block">
            <img src="${url}" class="preview">
            <p><b>${file.name}</b></p>

            <input type="text" placeholder="Brand" class="brand">
            <input type="text" placeholder="Product Name" class="item">
            <input type="text" placeholder="Material / Category" class="category">
            <input type="text" placeholder="Size (e.g. L, XL, XXL)" class="size">
            <input type="text" placeholder="Price (numbers only)" class="price">
            <input type="text" placeholder="Length (e.g. 6 ft)" class="length">
            <input type="text" placeholder="Width (e.g. 4 ft)" class="width">
            <textarea placeholder="Other details / description" class="details"></textarea>

            <button class="download-btn" onclick="createLabeledImage(this, ${i})">
                Download Image
            </button>
        </div>`;
    }

    document.getElementById("formHolder").innerHTML = html;
};

/* ====================================
   METADATA COLLECTOR
===================================== */
function extractMetadata(block, file) {
    return {
        filename: file.name,
        brand: block.querySelector(".brand").value || "",
        product: block.querySelector(".item").value || "",
        category: block.querySelector(".category").value || "",
        size: block.querySelector(".size").value || "",
        price: block.querySelector(".price").value || "",
        length: block.querySelector(".length").value || "",
        width: block.querySelector(".width").value || "",
        details: block.querySelector(".details").value || "",
        createdAt: new Date().toISOString()
    };
}

/* ====================================
   SINGLE DOWNLOAD BUTTON
===================================== */
async function createLabeledImage(btn, index) {
    const block = btn.parentElement;
    const file = document.getElementById("multiInput").files[index];
    if (!file) return;

    const meta = extractMetadata(block, file);
    const imgEl = block.querySelector("img.preview");

    const canvas = await generateLabeledCanvas(imgEl, meta);
    const dataURL = canvas.toDataURL("image/png");
    const pngWithMeta = addMetadataToPngDataURL(dataURL, meta);

    downloadDataURL(pngWithMeta, "labeled_" + file.name + ".png");
}

/* ====================================
   DOWNLOAD ALL (ZIP)
===================================== */
document.getElementById("downloadAllBtn").onclick = async function() {
    const files = document.getElementById("multiInput").files;
    if (!files.length) return alert("Upload images first!");

    const blocks = document.querySelectorAll(".image-block");
    const zip = new JSZip();

    const metaList = Array.from(files).map((file, idx) =>
        extractMetadata(blocks[idx], file)
    );

    const canvases = await Promise.all(
        metaList.map((meta, idx) => {
            const imgEl = blocks[idx].querySelector("img.preview");
            return generateLabeledCanvas(imgEl, meta);
        })
    );

    canvases.forEach((canvas, idx) => {
        const meta = metaList[idx];
        const file = files[idx];

        const dataURL = canvas.toDataURL("image/png");
        const finalURL = addMetadataToPngDataURL(dataURL, meta);
        const base64 = finalURL.split(",")[1];

        zip.file("labeled_" + file.name + ".png", base64, { base64: true });
    });

    const blob = await zip.generateAsync({ type: "blob" });

    const a = document.createElement("a");
    a.href = URL.createObjectURL(blob);
    a.download = "labeled_images.zip";
    a.click();
};

/* ====================================
   CANVAS GENERATION
   (FULL URL FIX INCLUDED)
===================================== */
function generateLabeledCanvas(imgEl, meta) {
    return new Promise(resolve => {
        const baseImage = new Image();
        baseImage.crossOrigin = "anonymous";

        const source = imgEl.src;

        baseImage.src = source.startsWith("blob:")
            ? source
            : BASE_URL + source.replace(/^\//, "");

        baseImage.onload = function() {
            const canvas = document.createElement("canvas");
            const ctx = canvas.getContext("2d");

            canvas.width = baseImage.width;
            canvas.height = baseImage.height;

            ctx.drawImage(baseImage, 0, 0);

            if (logoImageURL) {
                const logo = new Image();
                logo.crossOrigin = "anonymous";
                logo.src = logoImageURL;

                logo.onload = function() {
                    const logoW = canvas.width * 0.16;
                    const logoH = logo.height * (logoW / logo.width);

                    ctx.drawImage(logo, 40, 40, logoW, logoH);
                    drawTextBox(canvas, ctx, canvas.width, canvas.height, meta);
                    resolve(canvas);
                };
            } else {
                drawTextBox(canvas, ctx, canvas.width, canvas.height, meta);
                resolve(canvas);
            }
        };
    });
}

/* ====================================
   TEXT BOX DRAWING
===================================== */
function drawTextBox(canvas, ctx, w, h, meta) {
    const paddingX = 25;
    const paddingY = 30;

    const lines = [];
    if (meta.brand) lines.push(meta.brand);
    if (meta.product) lines.push(meta.product);
    if (meta.category) lines.push(meta.category);
    if (meta.size) lines.push("Size – " + meta.size);
    if (meta.price) lines.push("Price – Rs " + meta.price);
    if (meta.length) lines.push("Length – " + meta.length);
    if (meta.width) lines.push("Width – " + meta.width);

    if (meta.details) {
        lines.push("");
        meta.details.split("\n").forEach(l => lines.push(l.trim()));
    }

    const fontSize = Math.max(18, Math.round(w * 0.023));
    ctx.font = "bold " + fontSize + "px Arial";

    const boxWidth = Math.min(w * 0.38, 520);
    const textMax = boxWidth - paddingX * 2;

    const wrapped = [];
    lines.forEach(line => {
        if (!line) {
            wrapped.push("");
        } else {
            wrapped.push(...wrapText(ctx, line, textMax));
        }
    });

    const lineHeight = fontSize + 8;
    const boxHeight = paddingY * 2 + wrapped.length * lineHeight;

    const boxX = w - boxWidth - 40;
    const boxY = h - boxHeight - 40;

    ctx.fillStyle = "rgba(255,255,255,0.55)";
    ctx.roundRect(boxX, boxY, boxWidth, boxHeight, 22);
    ctx.fill();

    ctx.fillStyle = "black";
    ctx.font = "bold " + fontSize + "px Arial";

    let y = boxY + paddingY + fontSize;
    wrapped.forEach(line => {
        if (line === "") {
            y += lineHeight;
        } else {
            ctx.fillText(line, boxX + paddingX, y);
            y += lineHeight;
        }
    });
}

/* ====================================
   WORD WRAP HELPER
===================================== */
function wrapText(ctx, text, maxWidth) {
    const words = text.split(/\s+/);
    const lines = [];
    let line = "";

    for (let word of words) {
        const test = line ? line + " " + word : word;
        if (ctx.measureText(test).width > maxWidth && line) {
            lines.push(line);
            line = word;
        } else {
            line = test;
        }
    }

    if (line) lines.push(line);
    return lines;
}

/* ====================================
   DOWNLOAD HELPER
===================================== */
function downloadDataURL(dataURL, filename) {
    const a = document.createElement("a");
    a.download = filename;
    a.href = dataURL;
    a.click();
}

/* ====================================
   PNG METADATA (UNCHANGED)
===================================== */
function addMetadataToPngDataURL(dataURL, metadata) {
    try {
        const json = JSON.stringify(metadata);
        const base64 = dataURL.split(",")[1];
        const binary = atob(base64);
        const len = binary.length;
        const bytes = new Uint8Array(len);

        for (let i = 0; i < len; i++) bytes[i] = binary.charCodeAt(i);

        let offset = 8, iendIndex = -1;

        while (offset < bytes.length) {
            const length = readUint32(bytes, offset);
            const type = readType(bytes, offset + 4);
            if (type === "IEND") { iendIndex = offset; break; }
            offset += 8 + length + 4;
        }

        if (iendIndex < 0) return dataURL;

        const keyword = "label_metadata";
        const text = keyword + "\0" + json;
        const textBytes = new TextEncoder().encode(text);

        const chunkType = stringToBytes("tEXt");
        const lengthBytes = uint32ToBytes(textBytes.length);

        const crcInput = new Uint8Array(chunkType.length + textBytes.length);
        crcInput.set(chunkType, 0);
        crcInput.set(textBytes, chunkType.length);

        const crcVal = crc32(crcInput);
        const crcBytes = uint32ToBytes(crcVal);

        const newChunk = new Uint8Array(4 + 4 + textBytes.length + 4);
        newChunk.set(lengthBytes, 0);
        newChunk.set(chunkType, 4);
        newChunk.set(textBytes, 8);
        newChunk.set(crcBytes, 8 + textBytes.length);

        const before = bytes.subarray(0, iendIndex);
        const after = bytes.subarray(iendIndex);

        const output = new Uint8Array(before.length + newChunk.length + after.length);
        output.set(before, 0);
        output.set(newChunk, before.length);
        output.set(after, before.length + newChunk.length);

        let outBinary = "";
        for (let i = 0; i < output.length; i++)
            outBinary += String.fromCharCode(output[i]);

        return "data:image/png;base64," + btoa(outBinary);
    } catch (err) {
        console.error("Metadata embedding failed:", err);
        return dataURL;
    }
}

/* PNG HELPERS */
function readUint32(b, o) {
    return ((b[o] << 24) | (b[o+1] << 16) | (b[o+2] << 8) | b[o+3]) >>> 0;
}
function readType(b, o) {
    return String.fromCharCode(b[o], b[o+1], b[o+2], b[o+3]);
}
function uint32ToBytes(num) {
    return new Uint8Array([
        (num >>> 24) & 255,
        (num >>> 16) & 255,
        (num >>> 8) & 255,
        num & 255
    ]);
}
function stringToBytes(str) {
    return new Uint8Array([...str].map(c => c.charCodeAt(0)));
}

let crcTable = null;
function crc32(arr) {
    if (!crcTable) {
        crcTable = [];
        for (let i = 0; i < 256; i++) {
            let c = i;
            for (let k = 0; k < 8; k++) {
                c = (c & 1) ? (0xEDB88320 ^ (c >>> 1)) : (c >>> 1);
            }
            crcTable[i] = c >>> 0;
        }
    }

    let crc = 0 ^ (-1);
    for (let i = 0; i < arr.length; i++) {
        crc = (crc >>> 8) ^ crcTable[(crc ^ arr[i]) & 0xFF];
    }
    return (crc ^ (-1)) >>> 0;
}

/* Rounded rectangle support */
CanvasRenderingContext2D.prototype.roundRect = function (x, y, w, h, r) {
    if (w < 2 * r) r = w / 2;
    if (h < 2 * r) r = h / 2;
    this.beginPath();
    this.moveTo(x+r, y);
    this.arcTo(x+w, y,   x+w, y+h, r);
    this.arcTo(x+w, y+h, x,   y+h, r);
    this.arcTo(x,   y+h, x,   y,   r);
    this.arcTo(x,   y,   x+w, y,   r);
    this.closePath();
    return this;
};
</script>

</body>
</html>
